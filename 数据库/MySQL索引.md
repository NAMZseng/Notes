# MySQL索引

索引是一个单独的、存储在磁盘上的数据库结构（MySQL的InnoDB使用B+Tree），包含着对数据表里所有记录的引用指针。

## 聚簇索引

![image-20210808093555086](https://cdn.jsdelivr.net/gh/NAMZseng/Picture/img/image-20210808093555086.png)

-   表的数据与索引存储在一起，数据会跟随主键的顺序进行存储，因此一个表仅有一个聚簇索引，即主键索引；
-   在 MySQL数据库的 InnoDB存储引擎中，主键索引就是聚簇索引，所有数据都会按照主键索引进行组织排序；而在MyISAM存储引擎中，没有聚簇索引，因为MyISAM存储引擎中的数据不是按索引顺序进行存储的；

## 二级索引

![image-20210808094431650](https://cdn.jsdelivr.net/gh/NAMZseng/Picture/img/image-20210808094431650.png)

-   除主键索引外，其余的都为二级索引；
-   叶子节点存储的是主键值，查询时先通过索引查到对应列的主键，再通过主键索引查询到具体的数据（回表），即一次查询需要走两次索引；
-   主键的大小会影响所有索引的大小，包括聚簇索引和二级索引；

## 联合索引

![image-20210808095223192](https://cdn.jsdelivr.net/gh/NAMZseng/Picture/img/image-20210808095223192.png)

-   key由多个字段组成（一般不少超过5列），按最左匹配原则，从第一列开始排序，第一列相同再按第二列排序，以次类推；

    例：设有 union_key(a, b, c)，则查询（a=xxx, c = xxx)时，不会使用联合索引，因为联合索引不可跳过中间列查询；

    另：查询（c=xxx, b=xxx, a=xxx）时，会使用联合索引，因为有查询优化，会将查询顺序调整为联合索引的顺序；

-   对于联合索引中字段的顺序问题，按字段的区分度排序，即哪个字段不同的值多，就排前面，这样每次筛选时都可以尽可能多的排除无关项；

### 覆盖索引

通过索引就可以查询到所需要的数据，而不必通过二级索引回表查询数据。

如需要通过用户uid查询手机号phone，可以创建一个联合索引（uid，phone），这样当找到uid的同时就可以直接读取到phone，而无需再通过主键索引回表查询相关数据，大大提高了查询效率。

## 前缀索引

对于TEXT或很长的VARCHAR类型的列，且前缀区分度较好，可选取部分前缀字符作用索引。

前缀索引长度的衡量（以email为例）

-   使用 `select count(distinct email) as L from t;` 查询email字段不同值的个数；

-   依次选取不同的前缀长度，查看不同值的个数；

    ```sql
    select
        count(distinct left(email,4)）as L4,
        count(distinct left(email,5)）as L5,
        count(distinct left(email,6)）as L6,
        count(distinct left(email,7)）as L7,
    from t;
    ```

-   然后根据实际可接受的损失比例，选取适合的最短的前缀长度。一般选取最接近 L 的 Li，但也不要超过10；

注：使用前缀索引虽然能节省空间保证效率，但却不能用到覆盖索引的特性。

## 索引失效

-   对联合索引，当使用or查询时，如查询（a=xx, b =xx），不会走联合索引。

    注：若a，b分别为单独的索引，则查询时两个索引均会使用，因为从MySQL5.1开始，引入了Index Merge，可以对一个表使用两个索引分别扫描，再取结果的并集。

-   隐式类型转换

    当查询语句中的索引字段类型与定义的不匹配时，MySQL会自动进行全表扫描，从而造成索引失效。

-   查询超过索引范围

    如id字段仅有1000条数据，但使用where id > 2000时，由于查询条件已经超出索引范围，故不再使用索引，而直接进行全表扫描。

-   对索引列进行运算

    where id + 1 > 12		(id索引失效)

    where id > 12 - 1		 (id 索引列正常)

## 索引的存储空间

假设一个page16KB，使用BIGINT主键（8B），指针大小也为8B

则每页大约可存 16KB / (8B(主键) + 8B(指针)) = 1k 条记录

则对于3层的B+Tree，大约可存1K * 1K * 1K = 10亿条记录