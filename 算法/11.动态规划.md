# 0.理论基础
动态规划算法的基本思想：
- 将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；
- 对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。
  
动态规划与贪心算法的区别：
- 动态规划中每一个状态一定是由上一个状态推导出来的
- 贪心算法是局部直接选最优的，没有状态推导

动态规划问题解题步骤：
- 确定dp数组以及下标的含义
- 确定递推公式
- 确定dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。**


# 1.基础题目
- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/submissions/)
- [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/submissions/)
- [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/submissions/)
- [62. 不同路径](https://leetcode.cn/problems/unique-paths/submissions/)
- [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/submissions/)
- [343. 整数拆分](https://leetcode.cn/problems/integer-break/submissions/)
- [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

# 2.背包问题
背包问题分类：
![416.分割等和子集1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png)

## 2.1 01背包

### 理论基础：二维dp数组

有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包，能使得所装物品价值总和最大。

例如：

背包最大容量为4，

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能装的物品最大价值总和是多少？

下面使用动态规划算法解题：

- 1.确定dp数组以及下标的含义
  - **dp[i][j]的含义：从第0～i件物品中任意取，放进容量为j的背包中，能获得的最大价值总和。**
  - 根据dp数组的定义，可以得到推论1：dp[i][j] >= dp[i][j-1]，即物品种类确定时，背包容量越大，能获得的最大价值总和就可能越大。

- 2.确定递推公式
  
  对于每件物品i，有以下两种情况：
  -  **不放物品i**：当物品i的重量大于背包的重量时（weight[i] > j），物品i无法放进容量为j的背包中，所以背包内的价值依然和前面相同，即dp[i][j] = dp[i - 1][j]。
  -  **放入物品i**：当weight[i] <= j，物品i就可以放入容量为j的背包中，此时理论上物品i可在dp[i-1][0～j - weight[i]]的任意一个时刻放入背包中，但由之前但推理1可知，对于容量为j的背包，物品i在 dp[i - 1][j - weight[i]] 时刻放入, 可以得到最大价值，为dp[i - 1][j - weight[i]] + value[i]。
  - 所以递推公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

- 3.确定dp数组如果初始化
  - 如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和都为0，故需初始化dp[i][0] = 0 (0 <= i < n)。
  - 由递推公式可以看出dp[i] 是由 dp[i-1] 推导出来，那么i为0的时候就一定要初始化，即求只有物品0时，不同容量的背包的最大价值总和。
  - 对于剩余元素，由于都是基于上述已初始化的部分推导而来，所以可是先初始化为任意值，这里可以统一初始化为0。
 
     此时dp数组初始化情况如下图所示：
      ![动态规划-背包问题10](https://code-thinking-1253855093.file.myqcloud.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)
    
- 4.确定遍历顺序
  
  由递推公式中可以看出，dp[i][j] 是由 dp[i-1][j] 和 dp[i - 1][j - weight[i]] 推导出来的，且这两个都在dp[i][j]的左上角方向（包括正上方向和左上方向）。

  因此，无论是先遍历物品（i轴）再遍历背包（j轴），还是先遍历背包（j轴）再遍历物品（i轴），这两种遍历方式都是先更新 dp[i][j] 左上角的元素，因此这两种方式遍历方式都可。
  
  - 先遍历物品，再遍历背包的过程如下图所示：

    ![动态规划-背包问题5](https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png)

  - 先遍历背包，再遍历物品，如下图所示：

    ![动态规划-背包问题6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png)
  
- 5.举例推导dp数组

  本题的dp数组经推导后如下图所示，最终背包能装的物品最大价值总和为dp[2][4]，即35。

  ![动态规划-背包问题4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129.jpg)

代码实现：
```python
def bag_problem_01(weight, value, bag_weight):
    # dp数组初始化
    dp = [[0] * (bag_weight + 1) for _ in range(len(weight))]
    for j in range(weight[0], bag_weight + 1):
        dp[0][j] = value[0]

    for i in range(1, len(weight)):  # 遍历物品
        for j in range(1, bag_weight + 1):  # 遍历背包容量
            if j < weight[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

    return dp[len(weight) - 1][bag_weight]

if __name__ == "__main__":

    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4

    result = bag_problem_01(weight, value, bag_weight)
    print(result)
```

### 理论基础：一维dp数组

在使用二维数组的时候，递推公式为：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])。

其实在求dp[i]这一层的时候，**如果先把dp[i - 1]那一层拷贝到dp[i]上**，那么此时的递推公式就是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])。

那么再进一步思考，与其每次把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组，每次在原数组上操作（也可以理解是一个滚动数组）。

此时的递推公式可以化简为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

为什么能从二维数组化简为一维数组呢？
  - 由二维数组的递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])，可知，**dp[i][j]只与上一层的前部分(<=j)有关**。因此，在推导时，dp数组其实只需要保留上一层的信息即可，无需再保留上两层、上三层等更上面层的信息。

  - 另：为什么是简化为一横行的一维数组（即复用物品i轴），而不能简化为一竖行的一维数组（即复用背包j轴）？因为**dp[i][j]只与上一层的前部分(<=j)有关**，即dp[i-1]。而dp[i - 1][j - weight[i]]，是在dp[i][j]的前weight[i]竖行，不是固定的前一竖行。因此简化为一竖行不能提供足够的信息来推导dp[i][j]。

下面使用一维dp数组求解01背包问题：

- 1.确定dp数组以及下标的含义
  
  dp[j]：容量为j的背包，装物品能获得的最大价值。
  
- 2.确定递推公式
  
  dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

- 3.确定dp数组如何初始化

  dp[0]是0，因为背包容量为0所背的物品的最大价值就是0。
  
  对于dp数组剩下的元素（即非0下标），如果题目给的物品价值都是正整数，那么非0下标都初始化为0就可以了。因为对于一维dp数组，当不放该物品i时，递推公式中没有j-1，因此可以直接将对物品0的初始化代码合并到后面的遍历推导代码中，即直接从物品0开始遍历推导。

  当然也可以像二维dp数组初始化那样，先初始化求出当只有物品0时，不同容量的背包所能装的最大价值，然后遍历推导时直接从物品1开始。但这样代码其实是存在冗余的。

- 4.确定遍历顺序

  - 由二维dp数组的递推公式可知，dp[i][j]只与上一层的前部分(<=j)有关。因此当化简后使用一维数组时，需要**从后向前遍历dp[j]**，这样才能保证上一轮遍历的前部分结果，不会被此轮提前推导出的新值覆盖，从而影响此轮中后面元素的推导更新。
  
      如，在推导只有物品0 (weighg[0]=1, value[0] = 15)，不同容量的背包所能装的最大价值时，

      初始时，dp[0] = 0, dp[1] = 0, dp[2] = 0

      如果j从前往后遍历
    
      dp[1] = max(dp[1], dp[1 - weight[0]] + value[0]) = dp[0] + value[0] = 15
    
      dp[2] = max(dp[2], dp[2 - weight[0]] + value[0]) = **dp[1]** + value[0]

      此时，dp[2] 依赖的dp[1]已经不是初时的0， 而是在此轮被提前更新成了15，因此，dp[2]的计算是错误的！

       
  - 此外，在遍历时，需要**在外层for循环先遍历物品i，再在内层for循环从后往前推导dp[j]**。因为需要复用上一层物品i-1的推导结果。

- 5.举例推导dp数组

  一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

![动态规划-背包问题9](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103614769.png)

代码实现：
```python
def bag_problem_01(weight, value, bagWeight):
    # 初始化
    dp = [0] * (bagWeight + 1)

    # 先遍历物品
    for i in range(len(weight)): 
        # 再从后遍历背包容量，注意，j的取值范围是[bagWeight, weigh[i]], 即当j>weigh[i]时，才放入物品i
        for j in range(bagWeight, weight[i] - 1, -1):  
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    return dp[bagWeight]


if __name__ == "__main__":

    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagweight = 4

    result = bag_problem_01(weight, value, bagweight)
    print(result)
```

### 已刷题目


## 2.2 完全背包

## 2.3 多重背包

# 3.打家劫舍

# 4.股票问题

# 5.子序列问题

## 5.1 子序列（不连续）

## 5.2 子序列（连续）

## 5.3 编辑距离

## 5.4 回文

# 参考文章
- [代码随想录-动态规划](https://github.com/NAMZseng/leetcode-master/blob/master/problems/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md)
