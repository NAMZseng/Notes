# 0.理论基础
动态规划算法的基本思想：
- 将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；
- 对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。
  
动态规划与贪心算法的区别：
- 动态规划中每一个状态一定是由上一个状态推导出来的
- 贪心算法是局部直接选最优的，没有状态推导

动态规划问题解题步骤：
- 确定dp数组以及下标的含义
- 确定递推公式
- 确定dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。**


# 1.基础题目
- [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/submissions/)
- [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/submissions/)
- [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/submissions/)
- [62. 不同路径](https://leetcode.cn/problems/unique-paths/submissions/)
- [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/submissions/)
- [343. 整数拆分](https://leetcode.cn/problems/integer-break/submissions/)
- [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

# 2.背包问题
背包问题分类：
![416.分割等和子集1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png)

## 2.1 01背包
有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包，能使得所装物品价值总和最大。

例如：

背包最大容量为4，

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能装的物品最大价值总和是多少？

下面使用动态规划算法解题：

- 1.确定dp数组以及下标的含义
  - **dp[i][j]的含义：从第0～i件物品中任意取，放进容量为j的背包中，能获得的最大价值总和。**
  - 根据dp数组的定义，可以得到推论1：dp[i][j] >= dp[i][j-1]，即物品种类确定时，背包容量越大，能获得的最大价值总和就可能越大。

- 2.确定递推公式
  
  对于每件物品i，有以下两种情况：
  -  **不放物品i**：当物品i的重量大于背包的重量时（weight[i] > j），物品i无法放进容量为j的背包中，所以背包内的价值依然和前面相同，即dp[i][j] = dp[i - 1][j]。
  -  **放入物品i**：当weight[i] <= j，物品i就可以放入容量为j的背包中，此时理论上物品i可在dp[i-1][0～j - weight[i]]的任意一个时刻放入背包中，但由之前但推理1可知，对于容量为j的背包，物品i在 dp[i - 1][j - weight[i]] 时刻放入, 可以得到最大价值，为dp[i - 1][j - weight[i]] + value[i]。
  - 所以递推公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

- 3.确定dp数组如果初始化
  - 如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和都为0，故需初始化dp[i][0] = 0 (0 <= i < n)。
  - 由递推公式可以看出dp[i] 是由 dp[i-1] 推导出来，那么i为0的时候就一定要初始化，即求只有物品0时，不同容量的背包的最大价值总和。
  - 对于剩余元素，由于都是基于上述已初始化的部分推导而来，所以可是先初始化为任意值，这里可以统一初始化为0。
 
     此时dp数组初始化情况如下图所示：
      ![动态规划-背包问题10](https://code-thinking-1253855093.file.myqcloud.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)
    
- 4.确定遍历顺序
  
  由递推公式中可以看出，dp[i][j] 是由 dp[i-1][j] 和 dp[i - 1][j - weight[i]] 推导出来的，且这两个都在dp[i][j]的左上角方向（包括正上方向和左上方向）。

  因此，无论是先遍历物品（i轴）再遍历背包（j轴），还是先遍历背包（j轴）再遍历物品（i轴），这两种遍历方式都是先更新 dp[i][j] 左上角的元素，因此这两种方式遍历方式都可。
  
  - 先遍历物品，再遍历背包的过程如下图所示：

    ![动态规划-背包问题5](https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png)

  - 先遍历背包，再遍历物品，如下图所示：

    ![动态规划-背包问题6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png)
  
- 5.举例推导dp数组

  本题的dp数组经推导后如下图所示，最终背包能装的物品最大价值总和为dp[2][4]，即35。

  ![动态规划-背包问题4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129.jpg)

代码实现：
```python
def bag_problem_01(weight, value, bag_weight):
    # dp数组初始化
    dp = [[0] * (bag_weight + 1) for _ in range(len(weight))]
    for j in range(weight[0], bag_weight + 1):
        dp[0][j] = value[0]

    for i in range(1, len(weight)):  # 遍历物品
        for j in range(1, bag_weight + 1):  # 遍历背包容量
            if j < weight[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

    return dp[len(weight) - 1][bag_weight]

if __name__ == "__main__":

    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4

    result = bag_problem_01(weight, value, bag_weight)
    print(result)
```


## 2.2 完全背包

## 2.3 多重背包

# 3.打家劫舍

# 4.股票问题

# 5.子序列问题

## 5.1 子序列（不连续）

## 5.2 子序列（连续）

## 5.3 编辑距离

## 5.4 回文

# 参考文章
- [代码随想录-动态规划](https://github.com/NAMZseng/leetcode-master/blob/master/problems/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md)
