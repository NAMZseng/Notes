# 0.理论基础
排序算法可以分为 **内**部排序 和 **外**部排序
- 外部排序是因排序的数据很大，内存一次不能容纳全部的排序记录，在排序过程中需要访问外存。通常采用的是一种“**排序-归并**”的策略。
- 内部排序是数据记录在**内存**中进行排序。常见的内部排序算法如下图所示：
  ![十大经典内排序算法](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/sort.png)
  
  注：
  - in-place 表示占用常数内存，不占用额外内存；out-place 表示占用额外内存，开辟的辅助空间与问题规模有关。
  - 稳定性：若排序前后两个相等的数相对位置不变，则算法稳定。
  
# 1.冒泡排序

当输入的数据已经是正序时，算法最快。

当输入的数据已经是反序时，算法最慢。


## 算法步骤

核心思想：小的元素往前调或者把大的元素往后调。

  1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  
  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。**这步做完后，最后的元素会是最大的数**。
  
  3. 针对所有的元素重复以上的步骤，除了最后一个。
  
  4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

**稳定性说明**：比较是相邻的两个元素比较，交换也发生在这两个元素之间，当两相邻元素相等，不交换，从而保证了稳定性。


## 动图演示

![动图演示](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/bubbleSort.gif)


## 代码实现
```python
def bubble_sort(arr):
  n = len(arr)
  for i in range(1, n): # 比较n-1轮
    did_swap = False
    for j in range(0, n-i): # 每次从头开始两两比较，列表尾部的为已经比较过的有序序列
      if arr[j] > arr[j + 1]: # 做递增排序
          did_swap = True
          arr[j], arr[j+1] = arr[j+1], arr[j]
    if not did_swap: # 当遍历一轮也没有交换过，说明列表已经有序，此时时间复杂才为 O(n）
      return
```

# 2.选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。

## 算法步骤
核心思想：每个位置选择当前未排序元素中最小的。

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的**起始位置**。

2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3. 重复第二步，直到所有元素均排序完毕。

**不稳定性举例：** 序列 [5 5 2]，第一遍选择，第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了。

## 动图演示

![动图演示](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/selectionSort.gif)


## 代码实现

```python
def select_sort(arr):
  n = len(arr)
  for i in range(n-1): # 比较n-1轮
    min_idx = i
    for j in range(i+1, n): # 从剩余未排序元素中继续寻找最小元素（递增排序）
      if arr[j] < arr[min_idx]:
        min_idx = j

    if min_idx != i :
      arr[i], arr[min_idx] = arr[min_idx], arr[i]    
```

# 3.插入排序
它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序可通过折半查找，优化寻找插入位置的效率，不过每次仍然需要耗时移动元素。

## 算法步骤

核心思想：在已经有序的小序列的基础上，一次插入一个元素到相应位置。

1、已经有序的小序列的基础上，一次插入一个元素；

2、想要插入的元素和已经有序的最大者开始比起，如果大于等于最大者，则直接插入在其后面，否则一直往前找直到找到它该插入的位置；

3、相等元素的前后顺序没有改变，因此是是**稳定**的算法；


## 动图演示

![动图演示](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/insertionSort.gif)

## 代码实现

```python
def insert_sort(arr):
  n = len(arr)

  for i in range(1, n):
    current = arr[i]
    pre_idx = i-1
    while pre_idx > -1 and current < arr[pre_idx]:
      arr[pre_idx + 1] = arr[pre_idx] # 将大的元素后移
      pre_idx -= 1
    arr[pre_idx + 1] = current
```    

# 4.快速排序
快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

## 算法步骤

1. 从数列中挑出一个元素，称为 “基准”（pivot）;

2. 把所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）；

3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；当数列的大小是0或1，结束递归。


## 代码实现
```python
def quick_sort(arr, left, right): # 左闭右闭
  if left < right:
    pivot = partition(arr, left, right)
    quick_sort(arr, left, pivot-1)
    quick_sort(arr, pivot+1, right)

def partition(arr, left, right):
  mid = arr[right]
  pivot = left - 1 # arr[0 ~ pivot] 存放小于等于mid的元素
  for i in range(left, right):
    if arr[i] <= mid:
      pivot += 1
      arr[pivot], arr[i] = arr[i], arr[pivot]

  # for循环结束后，arr[pivot+1 ~ right-1] 存放的是比mid（也就是arr[right]）大的元素
  # 将right与pivot+1对应元素交换，使得arr[0 ~ pivot+1] 存放小于等于mid的元素，[pivot+2:]存放大于mid的元素
  arr[pivot+1], arr[right] = arr[right], arr[pivot+1]
  return pivot + 1
```

## 不稳定性分析

序列 [6 6 5]

第一次partition操作中，执行for循环后，pivot+1=0, right = 2

在执行```arr[pivot+1], arr[right] = arr[right], arr[pivot+1]```时，会将第一个6与5交换，此时两个6的先后顺序就改变了

因此快速排序是不稳定的。

# 参考文章
- [github.com/hustcc/JS-Sorting-Algorithm](https://github.com/hustcc/JS-Sorting-Algorithm)
- [排序算法的稳定性分析](https://cloud.tencent.com/developer/article/1182321)
