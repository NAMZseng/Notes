# 0.理论基础
排序算法可以分为 **内**部排序 和 **外**部排序
- 外部排序是因排序的数据很大，内存一次不能容纳全部的排序记录，在排序过程中需要访问外存。通常采用的是一种“**排序-归并**”的策略。
- 内部排序是数据记录在**内存**中进行排序。常见的内部排序算法如下图所示：
  ![十大经典内排序算法](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/sort.png)
  
  注：
  - in-place 表示占用常数内存，不占用额外内存；out-place 表示占用额外内存，开辟的辅助空间与问题规模有关。
  - 稳定性：若排序前后两个相等的数相对位置不变，则算法稳定。
  
# 1.冒泡排序

当输入的数据已经是正序时，算法最快。

当输入的数据已经是反序时，算法最慢。


## 算法步骤

核心思想：小的元素往前调或者把大的元素往后调。

  1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  
  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。**这步做完后，最后的元素会是最大的数**。
  
  3. 针对所有的元素重复以上的步骤，除了最后一个。
  
  4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

**稳定性说明**：比较是相邻的两个元素比较，交换也发生在这两个元素之间，当两相邻元素相等，不交换，从而保证了稳定性。


## 动图演示

![动图演示](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/bubbleSort.gif)


## 代码实现
```python
def bubble_sort(arr):
  n = len(arr)
  for i in range(1, n): # 比较n-1轮
    did_swap = False
    for j in range(0, n-i): # 每次从头开始两两比较，列表尾部的为已经比较过的有序序列
      if arr[j] > arr[j + 1]: # 做递增排序
          did_swap = True
          arr[j], arr[j+1] = arr[j+1], arr[j]
    if not did_swap: # 当遍历一轮也没有交换过，说明列表已经有序，此时时间复杂才为 O(n）
      return arr
  return arr
```

# 2.选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。

## 算法步骤
核心思想：每个位置选择当前未排序元素中最小的。

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的**起始位置**。

2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3. 重复第二步，直到所有元素均排序完毕。

**不稳定性举例：** 序列5 8 5 2 9， 第一遍选择，第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了。

## 动图演示

![动图演示](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/selectionSort.gif)


## 代码实现

```python
def select_sort(arr):
  n = len(arr)
  for i in range(n-1): # 比较n-1轮
    min_idx = i
    for j in range(i+1, n): # 从剩余未排序元素中继续寻找最小元素（递增排序）
      if arr[j] < arr[min_idx]:
        min_idx = j

    if min_idx != i :
      arr[i], arr[min_idx] = arr[min_idx], arr[i]

  return arr
    
```

# 3.插入排序
它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序可通过折半查找，优化寻找插入位置的效率，不过每次仍然需要耗时移动元素。

## 算法步骤

核心思想：在已经有序的小序列的基础上，一次插入一个元素到相应位置。

1、已经有序的小序列的基础上，一次插入一个元素；

2、想要插入的元素和已经有序的最大者开始比起，如果大于等于最大者，则直接插入在其后面，否则一直往前找直到找到它该插入的位置；

3、相等元素的前后顺序没有改变，因此是是稳定的算法；

## 代码实现

```python
def insert_sort(arr):
  n = len(arr)

  for i in range(1, n):
    current = arr[i]
    pre_idx = i-1
    while pre_idx > -1 and current < arr[pre_idx]:
      arr[pre_idx + 1] = arr[pre_idx]
      pre_idx -= 1
    arr[pre_idx + 1] = current

  return arr
```    

# 4.快速排序

# 5.归并排序

# 参考文章
- [github.com/hustcc/JS-Sorting-Algorithm](https://github.com/hustcc/JS-Sorting-Algorithm)
- [排序算法的稳定性分析](https://cloud.tencent.com/developer/article/1182321)
